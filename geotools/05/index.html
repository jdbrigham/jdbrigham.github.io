<!--code generated by Claude AI, November 2025-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Timeline Visualizer</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        // Lucide icons as inline SVG components
        const Upload = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const Download = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const Settings = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v6m-9-9h6m6 0h6"></path>
            </svg>
        );

        const MapPin = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        );

        const Activity = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
            </svg>
        );

        function TimelineVisualizer() {
            const [jsonData, setJsonData] = useState(null);
            const [allPoints, setAllPoints] = useState([]);
            const [svgContent, setSvgContent] = useState('');
            const [stats, setStats] = useState(null);
            const [dateRange, setDateRange] = useState({ start: '', end: '' });
            const [areaFilter, setAreaFilter] = useState({ enabled: false, minLat: '', maxLat: '', minLng: '', maxLng: '' });
            const [options, setOptions] = useState({
                width: 1200,
                height: 800,
                strokeColor: '#3b82f6',
                strokeWidth: 2,
                padding: 40,
                showPoints: true,
                pointRadius: 3,
                pointColor: '#ef4444',
                smoothPaths: false,
                colorByTime: false,
                showStartEnd: true,
                showMap: false,
                mapType: 'osm',
                mapStyle: 'standard',
                backgroundImage: null
            });
            const fileInputRef = useRef(null);
            const imageInputRef = useRef(null);

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const fileName = file.name.toLowerCase();
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        if (fileName.endsWith('.kml')) {
                            // Parse KML
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(event.target.result, 'text/xml');
                            const data = parseKML(xmlDoc);
                            setJsonData(data);
                            processData(data);
                        } else {
                            // Parse JSON
                            const data = JSON.parse(event.target.result);
                            setJsonData(data);
                            processData(data);
                        }
                    } catch (error) {
                        alert('Error parsing file: ' + error.message);
                    }
                };
                
                if (fileName.endsWith('.kml')) {
                    reader.readAsText(file);
                } else {
                    reader.readAsText(file);
                }
            };

            const parseKML = (xmlDoc) => {
                const placemarks = xmlDoc.getElementsByTagName('Placemark');
                const points = [];
                
                for (let placemark of placemarks) {
                    const nameEl = placemark.getElementsByTagName('name')[0];
                    const name = nameEl ? nameEl.textContent : '';
                    
                    const timeSpan = placemark.getElementsByTagName('TimeSpan')[0];
                    let startTime = null;
                    let endTime = null;
                    
                    if (timeSpan) {
                        const beginEl = timeSpan.getElementsByTagName('begin')[0];
                        const endEl = timeSpan.getElementsByTagName('end')[0];
                        startTime = beginEl ? beginEl.textContent : null;
                        endTime = endEl ? endEl.textContent : null;
                    }
                    
                    // Extract Point coordinates
                    const pointEl = placemark.getElementsByTagName('Point')[0];
                    if (pointEl) {
                        const coordsEl = pointEl.getElementsByTagName('coordinates')[0];
                        if (coordsEl) {
                            const coords = coordsEl.textContent.trim().split(',');
                            points.push({
                                lat: parseFloat(coords[1]),
                                lng: parseFloat(coords[0]),
                                timestamp: startTime,
                                type: 'place',
                                name: name
                            });
                        }
                    }
                    
                    // Extract LineString coordinates (paths)
                    const lineStringEl = placemark.getElementsByTagName('LineString')[0];
                    if (lineStringEl) {
                        const coordsEl = lineStringEl.getElementsByTagName('coordinates')[0];
                        if (coordsEl) {
                            const coordsText = coordsEl.textContent.trim();
                            const coordPairs = coordsText.split(' ').filter(c => c.trim());
                            
                            coordPairs.forEach((pair, idx) => {
                                const coords = pair.split(',');
                                if (coords.length >= 2) {
                                    points.push({
                                        lat: parseFloat(coords[1]),
                                        lng: parseFloat(coords[0]),
                                        timestamp: startTime,
                                        type: 'path',
                                        name: name,
                                        pathIndex: idx
                                    });
                                }
                            });
                        }
                    }
                }
                
                return points;
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    setOptions({...options, backgroundImage: event.target.result, showMap: true, mapType: 'custom'});
                    // Trigger re-render with the new background
                    setTimeout(() => {
                        if (jsonData) {
                            processData(jsonData);
                        }
                    }, 100);
                };
                reader.readAsDataURL(file);
            };

            const processData = (data) => {
                try {
                    const points = extractLocations(data);
                    
                    if (points.length === 0) {
                        alert('No location data found in the JSON file');
                        return;
                    }

                    // Store all points
                    setAllPoints(points);
                    
                    // Set initial date range if not set
                    if (points.length > 0 && !dateRange.start) {
                        const timestamps = points.map(p => new Date(p.timestamp)).filter(d => !isNaN(d));
                        if (timestamps.length > 0) {
                            timestamps.sort((a, b) => a - b);
                            setDateRange({
                                start: timestamps[0].toISOString().split('T')[0],
                                end: timestamps[timestamps.length - 1].toISOString().split('T')[0]
                            });
                        }
                    }

                    const bounds = getBounds(points);
                    
                    // Set initial area filter if not set
                    if (!areaFilter.enabled) {
                        setAreaFilter({
                            enabled: false,
                            minLat: bounds.minLat.toFixed(6),
                            maxLat: bounds.maxLat.toFixed(6),
                            minLng: bounds.minLng.toFixed(6),
                            maxLng: bounds.maxLng.toFixed(6)
                        });
                    }

                    setStats({
                        totalPoints: points.length,
                        dateRange: getDateRange(data),
                        bounds: bounds
                    });

                    const svg = generateSVG(points);
                    setSvgContent(svg);
                } catch (error) {
                    alert('Error processing data: ' + error.message);
                }
            };

            const extractLocations = (data) => {
                const points = [];
                
                // Handle KML parsed data (array of points)
                if (Array.isArray(data) && data.length > 0 && data[0].lat && data[0].lng) {
                    return data;
                }
                
                // Handle array of items (newest format with visit/activity objects)
                if (Array.isArray(data)) {
                    data.forEach(item => {
                        // New format with visit object
                        if (item.visit && item.visit.topCandidate && item.visit.topCandidate.placeLocation) {
                            const geoStr = item.visit.topCandidate.placeLocation;
                            const coords = parseGeoString(geoStr);
                            if (coords) {
                                points.push({
                                    lat: coords.lat,
                                    lng: coords.lng,
                                    timestamp: item.startTime || item.endTime,
                                    type: 'visit'
                                });
                            }
                        }
                        // New format with activity object
                        else if (item.activity) {
                            if (item.activity.start && item.activity.start.latLng) {
                                points.push({
                                    lat: item.activity.start.latLng.latitude,
                                    lng: item.activity.start.latLng.longitude,
                                    timestamp: item.startTime,
                                    type: 'activity'
                                });
                            }
                            if (item.activity.end && item.activity.end.latLng) {
                                points.push({
                                    lat: item.activity.end.latLng.latitude,
                                    lng: item.activity.end.latLng.longitude,
                                    timestamp: item.endTime,
                                    type: 'activity'
                                });
                            }
                        }
                    });
                }
                // Old format with timelineObjects
                else if (data.timelineObjects) {
                    data.timelineObjects.forEach(obj => {
                        if (obj.activitySegment) {
                            const seg = obj.activitySegment;
                            const timestamp = seg.duration?.startTimestamp || seg.duration?.startTimestampMs;
                            
                            if (seg.startLocation) {
                                points.push({
                                    lat: seg.startLocation.latitudeE7 / 1e7,
                                    lng: seg.startLocation.longitudeE7 / 1e7,
                                    timestamp,
                                    type: 'activity'
                                });
                            }
                            if (seg.endLocation) {
                                points.push({
                                    lat: seg.endLocation.latitudeE7 / 1e7,
                                    lng: seg.endLocation.longitudeE7 / 1e7,
                                    timestamp,
                                    type: 'activity'
                                });
                            }
                        } else if (obj.placeVisit) {
                            const loc = obj.placeVisit.location;
                            const timestamp = obj.placeVisit.duration?.startTimestamp || obj.placeVisit.duration?.startTimestampMs;
                            points.push({
                                lat: loc.latitudeE7 / 1e7,
                                lng: loc.longitudeE7 / 1e7,
                                timestamp,
                                type: 'place'
                            });
                        }
                    });
                }
                // Oldest format with locations array
                else if (data.locations) {
                    data.locations.forEach(loc => {
                        points.push({
                            lat: loc.latitudeE7 / 1e7,
                            lng: loc.longitudeE7 / 1e7,
                            timestamp: loc.timestamp || loc.timestampMs,
                            type: 'location'
                        });
                    });
                }
                
                return points.sort((a, b) => {
                    const timeA = new Date(a.timestamp).getTime();
                    const timeB = new Date(b.timestamp).getTime();
                    return timeA - timeB;
                });
            };

            const parseGeoString = (geoStr) => {
                // Parse "geo:42.351922,-71.055070" format
                const match = geoStr.match(/geo:([-\d.]+),([-\d.]+)/);
                if (match) {
                    return {
                        lat: parseFloat(match[1]),
                        lng: parseFloat(match[2])
                    };
                }
                return null;
            };

            const getBounds = (points) => {
                const lats = points.map(p => p.lat);
                const lngs = points.map(p => p.lng);
                
                return {
                    minLat: Math.min(...lats),
                    maxLat: Math.max(...lats),
                    minLng: Math.min(...lngs),
                    maxLng: Math.max(...lngs)
                };
            };

            const getDateRange = (data) => {
                let timestamps = [];
                
                // Handle array format (newest)
                if (Array.isArray(data)) {
                    data.forEach(item => {
                        if (item.startTime) timestamps.push(item.startTime);
                        if (item.endTime) timestamps.push(item.endTime);
                    });
                }
                // Old timelineObjects format
                else if (data.timelineObjects) {
                    data.timelineObjects.forEach(obj => {
                        if (obj.activitySegment?.duration?.startTimestamp) {
                            timestamps.push(obj.activitySegment.duration.startTimestamp);
                        } else if (obj.placeVisit?.duration?.startTimestamp) {
                            timestamps.push(obj.placeVisit.duration.startTimestamp);
                        }
                    });
                }
                // Oldest locations format
                else if (data.locations) {
                    timestamps = data.locations.map(l => l.timestamp || l.timestampMs);
                }
                
                if (timestamps.length === 0) return 'Unknown';
                
                timestamps.sort();
                const start = new Date(timestamps[0]).toLocaleDateString();
                const end = new Date(timestamps[timestamps.length - 1]).toLocaleDateString();
                return `${start} - ${end}`;
            };

            const projectToSVG = (point, bounds) => {
                const x = ((point.lng - bounds.minLng) / (bounds.maxLng - bounds.minLng)) 
                          * (options.width - 2 * options.padding) + options.padding;
                
                const y = ((bounds.maxLat - point.lat) / (bounds.maxLat - bounds.minLat)) 
                          * (options.height - 2 * options.padding) + options.padding;
                
                return { x, y, ...point };
            };

            const generatePathData = (points, smooth = false) => {
                if (points.length === 0) return '';
                
                if (!smooth) {
                    let path = `M ${points[0].x} ${points[0].y}`;
                    for (let i = 1; i < points.length; i++) {
                        path += ` L ${points[i].x} ${points[i].y}`;
                    }
                    return path;
                } else {
                    let path = `M ${points[0].x} ${points[0].y}`;
                    
                    for (let i = 0; i < points.length - 1; i++) {
                        const p0 = points[Math.max(i - 1, 0)];
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        const p3 = points[Math.min(i + 2, points.length - 1)];
                        
                        const cp1x = p1.x + (p2.x - p0.x) / 6;
                        const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6;
                        const cp2y = p2.y - (p3.y - p1.y) / 6;
                        
                        path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;
                    }
                    
                    return path;
                }
            };

            const generateSVG = (points) => {
                const bounds = getBounds(points);
                const svgPoints = points.map(p => projectToSVG(p, bounds));
                
                let svg = `<svg width="${options.width}" height="${options.height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <defs>
    <linearGradient id="pathGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
    </linearGradient>
  </defs>
  
`;

                // Add background
                if (options.showMap && options.mapType === 'osm') {
                    // Calculate appropriate zoom level based on route bounds
                    const latDiff = bounds.maxLat - bounds.minLat;
                    const lngDiff = bounds.maxLng - bounds.minLng;
                    const maxDiff = Math.max(latDiff, lngDiff);
                    
                    let zoom = 13;
                    if (maxDiff > 1) zoom = 9;
                    else if (maxDiff > 0.5) zoom = 10;
                    else if (maxDiff > 0.2) zoom = 11;
                    else if (maxDiff > 0.1) zoom = 12;
                    else if (maxDiff > 0.05) zoom = 13;
                    else if (maxDiff > 0.02) zoom = 14;
                    else zoom = 15;
                    
                    // Get tile coordinates for the bounds
                    const minTileX = lon2tile(bounds.minLng, zoom);
                    const maxTileX = lon2tile(bounds.maxLng, zoom);
                    const minTileY = lat2tile(bounds.maxLat, zoom); // Y is inverted
                    const maxTileY = lat2tile(bounds.minLat, zoom);
                    
                    // Convert tile coordinates back to lat/lng to get actual coverage
                    const tileBounds = {
                        minLng: tile2lon(minTileX, zoom),
                        maxLng: tile2lon(maxTileX + 1, zoom),
                        minLat: tile2lat(maxTileY + 1, zoom),
                        maxLat: tile2lat(minTileY, zoom)
                    };
                    
                    // Project function that accounts for tile bounds
                    const projectTileToSVG = (lat, lng) => {
                        const x = ((lng - tileBounds.minLng) / (tileBounds.maxLng - tileBounds.minLng)) 
                                  * (options.width - 2 * options.padding) + options.padding;
                        const y = ((tileBounds.maxLat - lat) / (tileBounds.maxLat - tileBounds.minLat)) 
                                  * (options.height - 2 * options.padding) + options.padding;
                        return { x, y };
                    };
                    
                    svg += `  <g id="map-tiles" opacity="0.6">\n`;
                    
                    // Draw tiles with slight overlap to avoid gaps
                    for (let ty = minTileY; ty <= maxTileY; ty++) {
                        for (let tx = minTileX; tx <= maxTileX; tx++) {
                            let tileUrl = '';
                            
                            switch(options.mapStyle) {
                                case 'toner':
                                    tileUrl = `https://tiles.stadiamaps.com/tiles/stamen_toner_lite/${zoom}/${tx}/${ty}.png`;
                                    break;
                                case 'terrain':
                                    tileUrl = `https://tiles.stadiamaps.com/tiles/stamen_terrain/${zoom}/${tx}/${ty}.jpg`;
                                    break;
                                case 'watercolor':
                                    tileUrl = `https://tiles.stadiamaps.com/tiles/stamen_watercolor/${zoom}/${tx}/${ty}.jpg`;
                                    break;
                                case 'carto-light':
                                    tileUrl = `https://a.basemaps.cartocdn.com/light_all/${zoom}/${tx}/${ty}.png`;
                                    break;
                                case 'carto-dark':
                                    tileUrl = `https://a.basemaps.cartocdn.com/dark_all/${zoom}/${tx}/${ty}.png`;
                                    break;
                                default:
                                    tileUrl = `https://tile.openstreetmap.org/${zoom}/${tx}/${ty}.png`;
                            }
                            
                            // Get tile corners in lat/lng
                            const tileMinLng = tile2lon(tx, zoom);
                            const tileMaxLng = tile2lon(tx + 1, zoom);
                            const tileMinLat = tile2lat(ty + 1, zoom);
                            const tileMaxLat = tile2lat(ty, zoom);
                            
                            // Project to SVG coordinates
                            const topLeft = projectTileToSVG(tileMaxLat, tileMinLng);
                            const bottomRight = projectTileToSVG(tileMinLat, tileMaxLng);
                            
                            const tileWidth = bottomRight.x - topLeft.x;
                            const tileHeight = bottomRight.y - topLeft.y;
                            
                            // Add 1px overlap on right and bottom edges to prevent gaps
                            svg += `    <image href="${tileUrl}" x="${topLeft.x}" y="${topLeft.y}" width="${tileWidth + 1}" height="${tileHeight + 1}" preserveAspectRatio="none"/>\n`;
                        }
                    }
                    
                    svg += `  </g>\n`;
                    
                    // Now re-project the points using the tile coordinate system
                    const reprojectedPoints = points.map(p => projectTileToSVG(p.lat, p.lng));
                    const pathData = generatePathData(reprojectedPoints, options.smoothPaths);
                    const strokeColor = options.colorByTime ? 'url(#pathGradient)' : options.strokeColor;
                    
                    svg += `  <path d="${pathData}" 
        fill="none" 
        stroke="${strokeColor}" 
        stroke-width="${options.strokeWidth}"
        stroke-linecap="round"
        stroke-linejoin="round"
        opacity="0.9"/>
`;

                    if (options.showPoints) {
                        reprojectedPoints.forEach((p, i) => {
                            const isStart = i === 0 && options.showStartEnd;
                            const isEnd = i === reprojectedPoints.length - 1 && options.showStartEnd;
                            const radius = (isStart || isEnd) ? options.pointRadius * 2 : options.pointRadius;
                            const color = isStart ? '#22c55e' : isEnd ? '#ef4444' : options.pointColor;
                            
                            svg += `  <circle cx="${p.x}" cy="${p.y}" r="${radius}" fill="${color}" opacity="0.9" stroke="white" stroke-width="1"/>\n`;
                        });
                    }

                    if (options.showStartEnd && reprojectedPoints.length > 0) {
                        const start = reprojectedPoints[0];
                        const end = reprojectedPoints[reprojectedPoints.length - 1];
                        
                        svg += `  <text x="${start.x}" y="${start.y - 15}" font-size="12" fill="#22c55e" font-weight="bold" text-anchor="middle" stroke="white" stroke-width="3" paint-order="stroke">START</text>\n`;
                        svg += `  <text x="${end.x}" y="${end.y - 15}" font-size="12" fill="#ef4444" font-weight="bold" text-anchor="middle" stroke="white" stroke-width="3" paint-order="stroke">END</text>\n`;
                    }
                    
                } else {
                    // No map or custom image
                    if (options.showMap && options.mapType === 'custom' && options.backgroundImage) {
                        svg += `  <image href="${options.backgroundImage}" x="0" y="0" width="${options.width}" height="${options.height}" opacity="0.6" preserveAspectRatio="xMidYMid slice"/>\n`;
                    } else {
                        svg += `  <rect width="100%" height="100%" fill="#f8fafc"/>\n`;
                    }

                    const pathData = generatePathData(svgPoints, options.smoothPaths);
                    const strokeColor = options.colorByTime ? 'url(#pathGradient)' : options.strokeColor;
                    
                    svg += `  <path d="${pathData}" 
        fill="none" 
        stroke="${strokeColor}" 
        stroke-width="${options.strokeWidth}"
        stroke-linecap="round"
        stroke-linejoin="round"
        opacity="0.9"/>
`;

                    if (options.showPoints) {
                        svgPoints.forEach((p, i) => {
                            const isStart = i === 0 && options.showStartEnd;
                            const isEnd = i === svgPoints.length - 1 && options.showStartEnd;
                            const radius = (isStart || isEnd) ? options.pointRadius * 2 : options.pointRadius;
                            const color = isStart ? '#22c55e' : isEnd ? '#ef4444' : options.pointColor;
                            
                            svg += `  <circle cx="${p.x}" cy="${p.y}" r="${radius}" fill="${color}" opacity="0.9" stroke="white" stroke-width="1"/>\n`;
                        });
                    }

                    if (options.showStartEnd && svgPoints.length > 0) {
                        const start = svgPoints[0];
                        const end = svgPoints[svgPoints.length - 1];
                        
                        svg += `  <text x="${start.x}" y="${start.y - 15}" font-size="12" fill="#22c55e" font-weight="bold" text-anchor="middle" stroke="white" stroke-width="3" paint-order="stroke">START</text>\n`;
                        svg += `  <text x="${end.x}" y="${end.y - 15}" font-size="12" fill="#ef4444" font-weight="bold" text-anchor="middle" stroke="white" stroke-width="3" paint-order="stroke">END</text>\n`;
                    }
                }

                svg += `</svg>`;
                return svg;
            };

            const lon2tile = (lon, zoom) => Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
            const lat2tile = (lat, zoom) => Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            
            const tile2lon = (x, zoom) => x / Math.pow(2, zoom) * 360 - 180;
            const tile2lat = (y, zoom) => {
                const n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
                return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
            };

            const updateVisualization = () => {
                if (allPoints.length === 0) return;
                
                // Filter points by date range
                let filteredPoints = allPoints.filter(p => {
                    if (!p.timestamp) return true;
                    const pointDate = new Date(p.timestamp);
                    if (isNaN(pointDate)) return true;
                    
                    const start = dateRange.start ? new Date(dateRange.start) : null;
                    const end = dateRange.end ? new Date(dateRange.end + 'T23:59:59') : null;
                    
                    if (start && pointDate < start) return false;
                    if (end && pointDate > end) return false;
                    return true;
                });
                
                // Filter points by area
                if (areaFilter.enabled) {
                    filteredPoints = filteredPoints.filter(p => {
                        if (areaFilter.minLat && p.lat < parseFloat(areaFilter.minLat)) return false;
                        if (areaFilter.maxLat && p.lat > parseFloat(areaFilter.maxLat)) return false;
                        if (areaFilter.minLng && p.lng < parseFloat(areaFilter.minLng)) return false;
                        if (areaFilter.maxLng && p.lng > parseFloat(areaFilter.maxLng)) return false;
                        return true;
                    });
                }
                
                if (filteredPoints.length === 0) {
                    alert('No points match the selected filters');
                    return;
                }
                
                const bounds = getBounds(filteredPoints);
                setStats({
                    totalPoints: filteredPoints.length,
                    dateRange: dateRange.start && dateRange.end ? `${dateRange.start} - ${dateRange.end}` : 'All dates',
                    bounds: bounds
                });
                
                const svg = generateSVG(filteredPoints);
                setSvgContent(svg);
            };

            const downloadSVG = () => {
                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'timeline-map.svg';
                a.click();
                URL.revokeObjectURL(url);
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-8">
                    <div className="max-w-7xl mx-auto">
                        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">
                            <div className="flex items-center justify-between mb-6">
                                <div>
                                    <h1 className="text-3xl font-bold text-slate-800 flex items-center gap-3">
                                        <MapPin size={32} className="text-blue-500" />
                                        Google Timeline Visualizer
                                    </h1>
                                    <p className="text-slate-600 mt-2">Convert your location history JSON to beautiful SVG maps</p>
                                    <p className="text-slate-500 text-sm mt-1">Supports JSON and KML formats</p>
                                </div>
                                <button
                                    onClick={() => fileInputRef.current?.click()}
                                    className="flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors"
                                >
                                    <Upload size={20} />
                                    Upload JSON
                                </button>
                                <input
                                    ref={fileInputRef}
                                    type="file"
                                    accept=".json,.kml"
                                    onChange={handleFileUpload}
                                    className="hidden"
                                />
                            </div>

                            {stats && (
                                <div className="grid grid-cols-3 gap-4 mb-6">
                                    <div className="bg-blue-50 rounded-lg p-4">
                                        <div className="flex items-center gap-2 text-blue-600 mb-1">
                                            <Activity size={18} />
                                            <span className="font-semibold">Total Points</span>
                                        </div>
                                        <div className="text-2xl font-bold text-slate-800">{stats.totalPoints.toLocaleString()}</div>
                                    </div>
                                    <div className="bg-green-50 rounded-lg p-4">
                                        <div className="flex items-center gap-2 text-green-600 mb-1">
                                            <MapPin size={18} />
                                            <span className="font-semibold">Date Range</span>
                                        </div>
                                        <div className="text-sm font-semibold text-slate-800">{stats.dateRange}</div>
                                    </div>
                                    <div className="bg-purple-50 rounded-lg p-4">
                                        <div className="flex items-center gap-2 text-purple-600 mb-1">
                                            <Settings size={18} />
                                            <span className="font-semibold">Area</span>
                                        </div>
                                        <div className="text-xs font-semibold text-slate-800">
                                            {stats.bounds.minLat.toFixed(2)}째, {stats.bounds.minLng.toFixed(2)}째 to {stats.bounds.maxLat.toFixed(2)}째, {stats.bounds.maxLng.toFixed(2)}째
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="bg-slate-50 rounded-lg p-6 mb-6">
                                <h2 className="text-lg font-semibold text-slate-800 mb-4 flex items-center gap-2">
                                    <Settings size={20} />
                                    Filters
                                </h2>
                                
                                {/* Date Range Filter */}
                                <div className="mb-6 pb-6 border-b border-slate-200">
                                    <h3 className="text-sm font-semibold text-slate-700 mb-3">Date Range</h3>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-medium text-slate-600 mb-1">Start Date</label>
                                            <input
                                                type="date"
                                                value={dateRange.start}
                                                onChange={(e) => setDateRange({...dateRange, start: e.target.value})}
                                                className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-slate-600 mb-1">End Date</label>
                                            <input
                                                type="date"
                                                value={dateRange.end}
                                                onChange={(e) => setDateRange({...dateRange, end: e.target.value})}
                                                className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                            />
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Area Filter */}
                                <div className="mb-4">
                                    <div className="flex items-center gap-2 mb-3">
                                        <input
                                            type="checkbox"
                                            id="areaFilterEnabled"
                                            checked={areaFilter.enabled}
                                            onChange={(e) => setAreaFilter({...areaFilter, enabled: e.target.checked})}
                                            className="w-4 h-4"
                                        />
                                        <label htmlFor="areaFilterEnabled" className="text-sm font-semibold text-slate-700 cursor-pointer">
                                            Filter by Geographic Area
                                        </label>
                                    </div>
                                    {areaFilter.enabled && (
                                        <div className="grid grid-cols-2 gap-4">
                                            <div>
                                                <label className="block text-sm font-medium text-slate-600 mb-1">Min Latitude</label>
                                                <input
                                                    type="number"
                                                    step="0.000001"
                                                    value={areaFilter.minLat}
                                                    onChange={(e) => setAreaFilter({...areaFilter, minLat: e.target.value})}
                                                    className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-slate-600 mb-1">Max Latitude</label>
                                                <input
                                                    type="number"
                                                    step="0.000001"
                                                    value={areaFilter.maxLat}
                                                    onChange={(e) => setAreaFilter({...areaFilter, maxLat: e.target.value})}
                                                    className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-slate-600 mb-1">Min Longitude</label>
                                                <input
                                                    type="number"
                                                    step="0.000001"
                                                    value={areaFilter.minLng}
                                                    onChange={(e) => setAreaFilter({...areaFilter, minLng: e.target.value})}
                                                    className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm font-medium text-slate-600 mb-1">Max Longitude</label>
                                                <input
                                                    type="number"
                                                    step="0.000001"
                                                    value={areaFilter.maxLng}
                                                    onChange={(e) => setAreaFilter({...areaFilter, maxLng: e.target.value})}
                                                    className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm"
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                <button
                                    onClick={updateVisualization}
                                    disabled={allPoints.length === 0}
                                    className="w-full bg-purple-500 hover:bg-purple-600 disabled:bg-slate-300 text-white px-6 py-3 rounded-lg transition-colors font-semibold"
                                >
                                    Apply Filters & Update
                                </button>
                            </div>

                            <div className="bg-slate-50 rounded-lg p-6 mb-6">
                                <h2 className="text-lg font-semibold text-slate-800 mb-4 flex items-center gap-2">
                                    <Settings size={20} />
                                    Visualization Options
                                </h2>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Width</label>
                                        <input
                                            type="number"
                                            value={options.width}
                                            onChange={(e) => setOptions({...options, width: parseInt(e.target.value)})}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Height</label>
                                        <input
                                            type="number"
                                            value={options.height}
                                            onChange={(e) => setOptions({...options, height: parseInt(e.target.value)})}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Stroke Width</label>
                                        <input
                                            type="number"
                                            value={options.strokeWidth}
                                            onChange={(e) => setOptions({...options, strokeWidth: parseInt(e.target.value)})}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Point Radius</label>
                                        <input
                                            type="number"
                                            value={options.pointRadius}
                                            onChange={(e) => setOptions({...options, pointRadius: parseInt(e.target.value)})}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Path Color</label>
                                        <input
                                            type="color"
                                            value={options.strokeColor}
                                            onChange={(e) => setOptions({...options, strokeColor: e.target.value})}
                                            className="w-full h-10 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Point Color</label>
                                        <input
                                            type="color"
                                            value={options.pointColor}
                                            onChange={(e) => setOptions({...options, pointColor: e.target.value})}
                                            className="w-full h-10 border border-slate-300 rounded-lg"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Map Background</label>
                                        <select
                                            value={options.showMap && options.mapType === 'custom' && options.backgroundImage ? 'custom' : (options.showMap ? options.mapType : 'none')}
                                            onChange={(e) => {
                                                const val = e.target.value;
                                                if (val === 'none') {
                                                    setOptions({...options, showMap: false});
                                                } else if (val === 'custom') {
                                                    // Trigger file input
                                                    setTimeout(() => {
                                                        imageInputRef.current?.click();
                                                    }, 0);
                                                } else {
                                                    setOptions({...options, showMap: true, mapType: val});
                                                }
                                            }}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                        >
                                            <option value="none">None</option>
                                            <option value="osm">Map Tiles</option>
                                            <option value="custom">Custom Image...</option>
                                        </select>
                                    </div>
                                    <div className="col-span-2">
                                        <label className="block text-sm font-medium text-slate-700 mb-1">Or Upload Custom Map Image</label>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={handleImageUpload}
                                            className="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm"
                                        />
                                    </div>
                                    <input
                                        ref={imageInputRef}
                                        type="file"
                                        accept="image/*"
                                        onChange={handleImageUpload}
                                        className="hidden"
                                    />
                                    {options.showMap && options.mapType === 'osm' && (
                                        <div>
                                            <label className="block text-sm font-medium text-slate-700 mb-1">Map Style</label>
                                            <select
                                                value={options.mapStyle}
                                                onChange={(e) => setOptions({...options, mapStyle: e.target.value})}
                                                className="w-full px-3 py-2 border border-slate-300 rounded-lg"
                                            >
                                                <option value="standard">Standard (OSM)</option>
                                                <option value="carto-light">Light (Minimal)</option>
                                                <option value="carto-dark">Dark</option>
                                                <option value="toner">Toner (B&W)</option>
                                                <option value="terrain">Terrain</option>
                                                <option value="watercolor">Watercolor</option>
                                            </select>
                                        </div>
                                    )}
                                    <div className="flex items-center">
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={options.showPoints}
                                                onChange={(e) => setOptions({...options, showPoints: e.target.checked})}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm font-medium text-slate-700">Show Points</span>
                                        </label>
                                    </div>
                                    <div className="flex items-center">
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={options.smoothPaths}
                                                onChange={(e) => setOptions({...options, smoothPaths: e.target.checked})}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm font-medium text-slate-700">Smooth Paths</span>
                                        </label>
                                    </div>
                                    <div className="flex items-center">
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={options.colorByTime}
                                                onChange={(e) => setOptions({...options, colorByTime: e.target.checked})}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm font-medium text-slate-700">Gradient Color</span>
                                        </label>
                                    </div>
                                    <div className="flex items-center">
                                        <label className="flex items-center gap-2 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={options.showStartEnd}
                                                onChange={(e) => setOptions({...options, showStartEnd: e.target.checked})}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm font-medium text-slate-700">Show Start/End</span>
                                        </label>
                                    </div>
                                </div>
                                <button
                                    onClick={updateVisualization}
                                    disabled={allPoints.length === 0}
                                    className="mt-4 w-full bg-green-500 hover:bg-green-600 disabled:bg-slate-300 text-white px-6 py-3 rounded-lg transition-colors"
                                >
                                    Update Visualization
                                </button>
                            </div>
                        </div>

                        {svgContent && (
                            <div className="bg-white rounded-xl shadow-lg p-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-xl font-semibold text-slate-800">Preview</h2>
                                    <button
                                        onClick={downloadSVG}
                                        className="flex items-center gap-2 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors"
                                    >
                                        <Download size={18} />
                                        Download SVG
                                    </button>
                                </div>
                                <div className="border-2 border-slate-200 rounded-lg p-4 bg-slate-50 overflow-auto">
                                    <div dangerouslySetInnerHTML={{ __html: svgContent }} />
                                </div>
                            </div>
                        )}

                        {!svgContent && (
                            <div className="bg-white rounded-xl shadow-lg p-12 text-center">
                                <Upload size={48} className="mx-auto text-slate-400 mb-4" />
                                <p className="text-slate-600 text-lg">Upload a Google Timeline JSON file to get started</p>
                                <p className="text-slate-500 text-sm mt-2">Supports both old and new Timeline formats</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<TimelineVisualizer />, document.getElementById('root'));
    </script>
</body>
</html>