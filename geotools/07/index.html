<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Georeferencer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #map { height: 600px; width: 100%; }
        .svg-overlay { pointer-events: none; }
        .svg-overlay.draggable { pointer-events: auto; cursor: move; }
        .control-point-marker { 
            background: #ef4444; 
            border: 3px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            margin-left: -8px;
            margin-top: -8px;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-50 to-indigo-100">
    <div class="max-w-7xl mx-auto p-6">
        <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-slate-800 mb-2">SVG Georeferencer</h1>
                    <p class="text-slate-600">Align your custom SVG maps with geographic coordinates</p>
                </div>
                <button id="toggleSidebar" class="px-4 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded-lg transition-colors">
                    ‚óÄ Hide Controls
                </button>
            </div>
        </div>

        <div class="grid gap-6" id="mainGrid" style="grid-template-columns: 400px 1fr;">
            <!-- Left Panel - Controls -->
            <div class="space-y-6" id="sidebar">
                <!-- Upload SVG -->
                <div class="bg-white rounded-xl shadow-lg">
                    <div class="p-4 border-b border-slate-200 flex items-center justify-between cursor-pointer" onclick="toggleSection('upload')">
                        <h2 class="text-lg font-semibold text-slate-800">1. Upload SVG</h2>
                        <span id="uploadToggle">‚ñº</span>
                    </div>
                    <div id="uploadContent" class="p-6">
                        <input type="file" id="svgUpload" accept=".svg" class="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm">
                        <div id="svgInfo" class="mt-3 text-sm text-slate-600"></div>
                    </div>
                </div>

                <!-- Map Location -->
                <div class="bg-white rounded-xl shadow-lg">
                    <div class="p-4 border-b border-slate-200 flex items-center justify-between cursor-pointer" onclick="toggleSection('location')">
                        <h2 class="text-lg font-semibold text-slate-800">2. Set Map Location</h2>
                        <span id="locationToggle">‚ñº</span>
                    </div>
                    <div id="locationContent" class="p-6 space-y-3">
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-1">Quick Location</label>
                            <select id="quickLocation" class="w-full px-3 py-2 border border-slate-300 rounded-lg text-sm">
                                <option value="">Choose a location...</option>
                                <option value="42.3601,-71.0589,13">Boston, MA</option>
                                <option value="43.4829,-73.2143,13">Poultney, VT</option>
                                <option value="43.6591,-70.2568,13">Portland, ME</option>
                                <option value="44.3106,-69.7795,13">Augusta, ME</option>
                            </select>
                        </div>
                        <div>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="freezeMap" class="w-4 h-4">
                                <span class="text-sm font-medium text-slate-700">üîí Freeze Map (prevent pan/zoom)</span>
                            </label>
                        </div>
                        <div class="text-xs text-slate-500 text-center">Pan/zoom the map manually</div>
                    </div>
                </div>

                <!-- SVG Controls -->
                <div class="bg-white rounded-xl shadow-lg">
                    <div class="p-4 border-b border-slate-200 flex items-center justify-between cursor-pointer" onclick="toggleSection('align')">
                        <h2 class="text-lg font-semibold text-slate-800">3. Align SVG</h2>
                        <span id="alignToggle">‚ñº</span>
                    </div>
                    <div id="alignContent" class="p-6 space-y-4">
                        <div>
                            <label class="flex items-center gap-2 cursor-pointer mb-2">
                                <input type="checkbox" id="dragMode" class="w-4 h-4">
                                <span class="text-sm font-medium text-slate-700">‚úã Enable SVG Drag Mode</span>
                            </label>
                            <p class="text-xs text-slate-500">Click and drag the SVG to position it</p>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-1">Opacity: <span id="opacityValue">50</span>%</label>
                            <input type="range" id="svgOpacity" min="0" max="100" value="50" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-1">Scale: <span id="scaleValue">1.0</span>x</label>
                            <input type="range" id="svgScale" min="0.1" max="3" step="0.1" value="1" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-1">Rotation: <span id="rotationValue">0</span>¬∞</label>
                            <input type="range" id="svgRotation" min="0" max="360" step="1" value="0" class="w-full">
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="moveUp" class="px-3 py-2 bg-slate-200 hover:bg-slate-300 rounded text-sm">‚Üë Up</button>
                            <button id="moveDown" class="px-3 py-2 bg-slate-200 hover:bg-slate-300 rounded text-sm">‚Üì Down</button>
                            <button id="moveLeft" class="px-3 py-2 bg-slate-200 hover:bg-slate-300 rounded text-sm">‚Üê Left</button>
                            <button id="moveRight" class="px-3 py-2 bg-slate-200 hover:bg-slate-300 rounded text-sm">‚Üí Right</button>
                        </div>
                        <button id="resetTransform" class="w-full px-3 py-2 bg-red-500 hover:bg-red-600 text-white rounded">Reset</button>
                    </div>
                </div>

                <!-- Control Points -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-lg font-semibold text-slate-800 mb-4">4. Mark Control Points</h2>
                    <div class="mb-3">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="markingMode" class="w-4 h-4">
                            <span class="text-sm font-medium text-slate-700">Enable Point Marking Mode</span>
                        </label>
                        <p class="text-xs text-slate-500 mt-1">Click on map to add reference points</p>
                    </div>
                    <div id="controlPointsList" class="space-y-2 mb-3">
                        <!-- Points will be added here -->
                    </div>
                    <button id="clearPoints" class="w-full px-3 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded text-sm">Clear All Points</button>
                </div>

                <!-- Export -->
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h2 class="text-lg font-semibold text-slate-800 mb-4">5. Export</h2>
                    <button id="exportSVG" class="w-full px-4 py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold">
                        Download Georeferenced SVG
                    </button>
                    <p class="text-xs text-slate-500 mt-2">Minimum 3 control points recommended</p>
                </div>
            </div>

            <!-- Right Panel - Map -->
            <div id="mapPanel">
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-slate-800">Interactive Map</h2>
                        <div class="text-sm text-slate-600">
                            Zoom: <span id="currentZoom">13</span> | 
                            Center: <span id="currentCenter">-</span>
                        </div>
                    </div>
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toggle sidebar visibility
        let sidebarVisible = true;
        document.getElementById('toggleSidebar').addEventListener('click', () => {
            const sidebar = document.getElementById('sidebar');
            const mainGrid = document.getElementById('mainGrid');
            const button = document.getElementById('toggleSidebar');
            
            sidebarVisible = !sidebarVisible;
            
            if (sidebarVisible) {
                sidebar.style.display = '';
                mainGrid.style.gridTemplateColumns = '400px 1fr';
                button.textContent = '‚óÄ Hide Controls';
            } else {
                sidebar.style.display = 'none';
                mainGrid.style.gridTemplateColumns = '1fr';
                button.textContent = '‚ñ∂ Show Controls';
            }
            
            // Resize map after layout change
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        });

        // Toggle individual sections
        window.toggleSection = function(section) {
            const content = document.getElementById(section + 'Content');
            const toggle = document.getElementById(section + 'Toggle');
            
            if (content.style.display === 'none') {
                content.style.display = '';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        };
    
        // Initialize map
        const map = L.map('map').setView([42.3601, -71.0589], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);

        // State
        let svgOverlay = null;
        let svgContent = null;
        let svgBounds = null;
        let controlPoints = [];
        let offsetLat = 0;
        let offsetLng = 0;
        let isDragging = false;
        let dragStart = null;

        // Update map info
        function updateMapInfo() {
            document.getElementById('currentZoom').textContent = map.getZoom();
            const center = map.getCenter();
            document.getElementById('currentCenter').textContent = 
                `${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}`;
        }
        map.on('moveend', updateMapInfo);
        map.on('zoomend', updateMapInfo);
        updateMapInfo();

        // Quick location
        document.getElementById('quickLocation').addEventListener('change', (e) => {
            if (e.target.value) {
                const [lat, lng, zoom] = e.target.value.split(',').map(Number);
                map.setView([lat, lng], zoom);
            }
        });

        // Freeze map
        document.getElementById('freezeMap').addEventListener('change', (e) => {
            if (e.target.checked) {
                map.dragging.disable();
                map.scrollWheelZoom.disable();
                map.doubleClickZoom.disable();
                map.boxZoom.disable();
                map.keyboard.disable();
                if (map.tap) map.tap.disable();
            } else {
                map.dragging.enable();
                map.scrollWheelZoom.enable();
                map.doubleClickZoom.enable();
                map.boxZoom.enable();
                map.keyboard.enable();
                if (map.tap) map.tap.enable();
            }
        });

        // SVG Upload
        document.getElementById('svgUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                svgContent = event.target.result;
                
                // Parse SVG to get viewBox
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                const svgEl = svgDoc.querySelector('svg');
                
                let viewBox = svgEl.getAttribute('viewBox');
                let svgWidth, svgHeight;
                
                if (viewBox) {
                    const parts = viewBox.split(/\s+/);
                    svgWidth = parseFloat(parts[2]);
                    svgHeight = parseFloat(parts[3]);
                } else {
                    svgWidth = parseFloat(svgEl.getAttribute('width')) || 1000;
                    svgHeight = parseFloat(svgEl.getAttribute('height')) || 800;
                }
                
                const svgAspectRatio = svgWidth / svgHeight;
                
                document.getElementById('svgInfo').innerHTML = 
                    `<div class="text-green-600">‚úì Loaded: ${file.name}</div>
                     <div class="text-xs mt-1">Dimensions: ${svgWidth.toFixed(0)} √ó ${svgHeight.toFixed(0)}</div>
                     <div class="text-xs">Aspect ratio: ${svgAspectRatio.toFixed(3)}</div>`;
                
                // Create initial overlay with correct aspect ratio
                const center = map.getCenter();
                const zoom = map.getZoom();
                
                // Calculate bounds that match SVG aspect ratio
                const mapBounds = map.getBounds();
                const latSpan = (mapBounds.getNorth() - mapBounds.getSouth()) * 0.4;
                
                // Adjust longitude span to match SVG aspect ratio
                // At this latitude, 1 degree lng ‚âà 0.72 degrees lat (cos of latitude)
                const latCorrectionFactor = Math.cos(center.lat * Math.PI / 180);
                const lngSpan = (latSpan / latCorrectionFactor) * svgAspectRatio;
                
                const initialBounds = [
                    [center.lat - latSpan, center.lng - lngSpan],
                    [center.lat + latSpan, center.lng + lngSpan]
                ];
                
                console.log('SVG aspect ratio:', svgAspectRatio);
                console.log('Initial bounds aspect:', (2 * lngSpan) / (2 * latSpan));
                
                createSVGOverlay(initialBounds);
            };
            reader.readAsText(file);
        });

        function createSVGOverlay(bounds) {
            if (svgOverlay) {
                map.removeLayer(svgOverlay);
            }
            
            console.log('createSVGOverlay called with bounds:', bounds);
            
            svgBounds = L.latLngBounds(bounds);
            
            console.log('svgBounds after L.latLngBounds:', svgBounds);
            console.log('svgBounds center:', svgBounds.getCenter());
            console.log('svgBounds N/S/E/W:', svgBounds.getNorth(), svgBounds.getSouth(), svgBounds.getEast(), svgBounds.getWest());
            
            const svgUrl = 'data:image/svg+xml;base64,' + btoa(svgContent);
            
            svgOverlay = L.imageOverlay(svgUrl, svgBounds, {
                opacity: 0.5,
                className: 'svg-overlay'
            }).addTo(map);
            
            offsetLat = 0;
            offsetLng = 0;
        }

        function updateSVGTransform() {
            if (!svgOverlay || !svgBounds) return;
            
            console.log('updateSVGTransform called');
            console.log('svgBounds:', svgBounds);
            console.log('offsetLat:', offsetLat, 'offsetLng:', offsetLng);
            
            const opacity = document.getElementById('svgOpacity').value / 100;
            const scale = parseFloat(document.getElementById('svgScale').value);
            const rotation = parseFloat(document.getElementById('svgRotation').value);
            
            // Get original bounds
            const origCenter = svgBounds.getCenter();
            const origNorth = svgBounds.getNorth();
            const origSouth = svgBounds.getSouth();
            const origEast = svgBounds.getEast();
            const origWest = svgBounds.getWest();
            
            console.log('Original center:', origCenter);
            console.log('Original bounds: N:', origNorth, 'S:', origSouth, 'E:', origEast, 'W:', origWest);
            
            // Apply offset to center
            const newCenterLat = origCenter.lat + offsetLat;
            const newCenterLng = origCenter.lng + offsetLng;
            
            console.log('New center:', newCenterLat, newCenterLng);
            
            // Calculate scaled bounds around new center
            const latRadius = (origNorth - origSouth) * scale / 2;
            const lngRadius = (origEast - origWest) * scale / 2;
            
            console.log('Radii - lat:', latRadius, 'lng:', lngRadius);
            
            const newBounds = [
                [newCenterLat - latRadius, newCenterLng - lngRadius],
                [newCenterLat + latRadius, newCenterLng + lngRadius]
            ];
            
            console.log('Raw new bounds array:', newBounds);
            
            const newLatLngBounds = L.latLngBounds(newBounds);
            console.log('After L.latLngBounds:', newLatLngBounds);
            console.log('_southWest:', newLatLngBounds.getSouthWest());
            console.log('_northEast:', newLatLngBounds.getNorthEast());
            
            // Convert lat/lng bounds to pixel positions
            const sw = map.latLngToLayerPoint(newLatLngBounds.getSouthWest());
            const ne = map.latLngToLayerPoint(newLatLngBounds.getNorthEast());
            
            console.log('SW pixel:', sw);
            console.log('NE pixel:', ne);
            
            const width = ne.x - sw.x;
            const height = sw.y - ne.y; // Note: Y is inverted in screen coords
            
            console.log('Calculated width:', width, 'height:', height);
            
            // Manually position the element
            const el = svgOverlay.getElement();
            if (el) {
                el.style.width = width + 'px';
                el.style.height = height + 'px';
                el.style.left = sw.x + 'px';
                el.style.top = ne.y + 'px';
                
                console.log('Set element position - left:', sw.x, 'top:', ne.y, 'width:', width, 'height:', height);
            }
            
            svgOverlay.setOpacity(opacity);
            
            // Apply rotation via CSS transform (do this AFTER adding to map)
            // Note: CSS transforms can affect positioning
            const element = svgOverlay.getElement();
            if (element && rotation !== 0) {
                element.style.transform = `rotate(${rotation}deg)`;
                element.style.transformOrigin = 'center';
                console.log('Applied rotation:', rotation, 'degrees');
            } else if (element) {
                element.style.transform = '';
                console.log('No rotation applied');
            }
            
            // Update draggable state
            updateDragMode();
        }

        function updateDragMode() {
            if (!svgOverlay) return;
            const element = svgOverlay.getElement();
            if (!element) return;
            
            const dragEnabled = document.getElementById('dragMode').checked;
            
            if (dragEnabled) {
                element.classList.add('draggable');
            } else {
                element.classList.remove('draggable');
            }
        }

        // Drag mode toggle
        document.getElementById('dragMode').addEventListener('change', updateDragMode);

        // SVG dragging functionality
        map.on('mousedown', (e) => {
            if (!document.getElementById('dragMode').checked || !svgOverlay) return;
            
            const element = svgOverlay.getElement();
            if (!element) return;
            
            // Check if click is on the SVG overlay
            const rect = element.getBoundingClientRect();
            const mouseX = e.originalEvent.clientX;
            const mouseY = e.originalEvent.clientY;
            
            if (mouseX >= rect.left && mouseX <= rect.right && 
                mouseY >= rect.top && mouseY <= rect.bottom) {
                isDragging = true;
                dragStart = e.latlng;
                // Temporarily disable map dragging only while actively dragging
                if (!document.getElementById('freezeMap').checked) {
                    map.dragging.disable();
                }
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
            }
        });

        map.on('mousemove', (e) => {
            if (!isDragging || !dragStart) return;
            
            const latDiff = e.latlng.lat - dragStart.lat;
            const lngDiff = e.latlng.lng - dragStart.lng;
            
            offsetLat += latDiff;
            offsetLng += lngDiff;
            
            dragStart = e.latlng;
            updateSVGTransform();
            
            e.originalEvent.preventDefault();
        });

        map.on('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                dragStart = null;
                // Re-enable map dragging after we're done, unless freeze is on
                if (!document.getElementById('freezeMap').checked) {
                    // Small delay to ensure the state is properly reset
                    setTimeout(() => {
                        map.dragging.enable();
                    }, 10);
                }
            }
        });

        // Controls
        document.getElementById('svgOpacity').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value;
            updateSVGTransform();
        });

        document.getElementById('svgScale').addEventListener('input', (e) => {
            document.getElementById('scaleValue').textContent = parseFloat(e.target.value).toFixed(1);
            updateSVGTransform();
        });

        document.getElementById('svgRotation').addEventListener('input', (e) => {
            document.getElementById('rotationValue').textContent = e.target.value;
            updateSVGTransform();
        });

        // Controls - adaptive move step based on zoom
        function getMoveStep() {
            const zoom = map.getZoom();
            // At zoom 13, use 0.01; double the step for each zoom level down
            return 0.01 * Math.pow(2, 13 - zoom);
        }
        
        document.getElementById('moveUp').addEventListener('click', () => {
            offsetLat += getMoveStep();
            console.log('Move Up - offsetLat:', offsetLat, 'offsetLng:', offsetLng);
            updateSVGTransform();
        });
        document.getElementById('moveDown').addEventListener('click', () => {
            offsetLat -= getMoveStep();
            console.log('Move Down - offsetLat:', offsetLat, 'offsetLng:', offsetLng);
            updateSVGTransform();
        });
        document.getElementById('moveLeft').addEventListener('click', () => {
            offsetLng -= getMoveStep();
            console.log('Move Left - offsetLat:', offsetLat, 'offsetLng:', offsetLng);
            updateSVGTransform();
        });
        document.getElementById('moveRight').addEventListener('click', () => {
            offsetLng += getMoveStep();
            console.log('Move Right - offsetLat:', offsetLat, 'offsetLng:', offsetLng);
            updateSVGTransform();
        });

        document.getElementById('resetTransform').addEventListener('click', () => {
            document.getElementById('svgOpacity').value = 50;
            document.getElementById('svgScale').value = 1;
            document.getElementById('svgRotation').value = 0;
            document.getElementById('opacityValue').textContent = '50';
            document.getElementById('scaleValue').textContent = '1.0';
            document.getElementById('rotationValue').textContent = '0';
            offsetLat = 0;
            offsetLng = 0;
            updateSVGTransform();
        });

        // Control Points
        map.on('click', (e) => {
            if (!document.getElementById('markingMode').checked) return;
            
            const pointNum = controlPoints.length + 1;
            const label = prompt(`Name for control point ${pointNum}:`, `Point ${pointNum}`);
            if (!label) return;
            
            const marker = L.marker(e.latlng, {
                icon: L.divIcon({
                    className: 'control-point-marker',
                    html: ''
                })
            }).addTo(map);
            
            const point = {
                label,
                lat: e.latlng.lat,
                lng: e.latlng.lng,
                marker
            };
            
            controlPoints.push(point);
            updateControlPointsList();
        });

        function updateControlPointsList() {
            const list = document.getElementById('controlPointsList');
            list.innerHTML = controlPoints.map((p, i) => `
                <div class="flex items-center justify-between p-2 bg-slate-50 rounded text-sm">
                    <div>
                        <div class="font-medium">${p.label}</div>
                        <div class="text-xs text-slate-500">${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}</div>
                    </div>
                    <button onclick="removePoint(${i})" class="text-red-500 hover:text-red-700">‚úï</button>
                </div>
            `).join('');
        }

        window.removePoint = function(index) {
            map.removeLayer(controlPoints[index].marker);
            controlPoints.splice(index, 1);
            updateControlPointsList();
        };

        document.getElementById('clearPoints').addEventListener('click', () => {
            controlPoints.forEach(p => map.removeLayer(p.marker));
            controlPoints = [];
            updateControlPointsList();
        });

        // Export
        document.getElementById('exportSVG').addEventListener('click', () => {
            if (!svgContent) {
                alert('Please upload an SVG first!');
                return;
            }
            
            if (controlPoints.length < 2) {
                alert('Please add at least 2 control points for better georeferencing!');
                return;
            }
            
            // Calculate bounds
            const lats = controlPoints.map(p => p.lat);
            const lngs = controlPoints.map(p => p.lng);
            const bounds = {
                minLat: Math.min(...lats),
                maxLat: Math.max(...lats),
                minLng: Math.min(...lngs),
                maxLng: Math.max(...lngs)
            };
            
            // Parse SVG and add metadata
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
            const svgEl = svgDoc.querySelector('svg');
            
            // Create metadata element
            const defs = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const metadata = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'metadata');
            metadata.setAttribute('id', 'geo-bounds');
            
            const georeference = svgDoc.createElement('georeference');
            
            const boundsEl = svgDoc.createElement('bounds');
            boundsEl.setAttribute('minLat', bounds.minLat.toFixed(6));
            boundsEl.setAttribute('maxLat', bounds.maxLat.toFixed(6));
            boundsEl.setAttribute('minLng', bounds.minLng.toFixed(6));
            boundsEl.setAttribute('maxLng', bounds.maxLng.toFixed(6));
            georeference.appendChild(boundsEl);
            
            const pointsEl = svgDoc.createElement('controlPoints');
            controlPoints.forEach(p => {
                const pointEl = svgDoc.createElement('point');
                pointEl.setAttribute('lat', p.lat.toFixed(6));
                pointEl.setAttribute('lng', p.lng.toFixed(6));
                pointEl.setAttribute('label', p.label);
                pointsEl.appendChild(pointEl);
            });
            georeference.appendChild(pointsEl);
            
            metadata.appendChild(georeference);
            defs.appendChild(metadata);
            
            // Insert at beginning of SVG
            if (svgEl.firstChild) {
                svgEl.insertBefore(defs, svgEl.firstChild);
            } else {
                svgEl.appendChild(defs);
            }
            
            // Serialize and download
            const serializer = new XMLSerializer();
            const output = serializer.serializeToString(svgDoc);
            
            const blob = new Blob([output], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'georeferenced-map.svg';
            a.click();
            URL.revokeObjectURL(url);
            
            alert(`Exported with ${controlPoints.length} control points!\n\nBounds: ${bounds.minLat.toFixed(4)}, ${bounds.minLng.toFixed(4)} to ${bounds.maxLat.toFixed(4)}, ${bounds.maxLng.toFixed(4)}`);
        });
    </script>
</body>
</html>